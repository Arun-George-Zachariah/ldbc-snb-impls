/* 
 * Copyright (C) 2016 Stanford University
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.ellitron.ldbcsnbimpls.interactive.neo4j.util;

/**
 * A utility for converting dataset files generated by the LDBC SNB Data
 * Generator[1] to the file format expected by the Neo4j import tool[2].
 * <p>
 * TODO:<br>
 * <ul>
 * <li>Add specific instructions.</li>
 * <li>Join language and e-mails into person node.</li>
 * </ul>
 * <p>
 * [1]: git@github.com:ldbc/ldbc_snb_datagen.git<br>
 * [2]: http://neo4j.com/docs/stable/import-tool.html<br>
 *
 * @author Jonathan Ellithorpe (jde@cs.stanford.edu)
 */
public class DataFormatConverter {

  /**
   * Represents all the types of nodes in the graph. Each node has an "ID
   * space" (see Neo4j Import Tool documentation) in which its
   * LDBC-SNB-Data-Generator-assigned ID is unique with every other node in
   * that space. For instance, comments and posts live in the "MESSAGE_ID"
   * space and all have unique IDs when considered together.
   *
   * Each node also has a "label". This is the label that's used to refer to
   * the node in Cypher queries. This label is overloaded in the sense that it
   * is also the string used to identify the dataset file containing these
   * nodes (e.g. person_0.0.csv)
   */
  private enum Node {

    COMMENT("MESSAGE_ID", "comment"),
    FORUM("FORUM_ID", "forum"),
    ORGANISATION("ORGANISATION_ID", "organisation"),
    PERSON("PERSON_ID", "person"),
    PLACE("PLACE_ID", "place"),
    POST("MESSAGE_ID", "post"),
    TAG("TAG_ID", "tag"),
    TAGCLASS("TAGCLASS_ID", "tagclass");

    private final String idSpace;
    private final String label;

    private Node(String idSpace, String label) {
      this.idSpace = idSpace;
      this.label = label;
    }

    public String getIdSpace() {
      return idSpace;
    }

    public String getLabel() {
      return label;
    }
  }

  /**
   * Represents all the types of relationships in the graph. Each relationship
   * has a "type" which is used to refer to relationships of that type in
   * Cypher queries. This "type" is overloaded in the sense that it is also
   * part of the filenames that contain relationships of this type (e.g.
   * person_isLocatedIn_place_0_0.csv).
   */
  private enum Relationship {

    CONTAINEROF("containerOf"),
    HASCREATOR("hasCreator"),
    HASINTEREST("hasInterest"),
    HASMEMBER("hasMember"),
    HASMODERATOR("hasModerator"),
    HASTAG("hasTag"),
    HASTYPE("hasType"),
    ISLOCATEDIN("isLocatedIn"),
    ISPARTOF("isPartOf"),
    ISSUBCLASSOF("isSubclassOf"),
    KNOWS("knows"),
    LIKES("likes"),
    REPLYOF("replyOf"),
    SPEAKS("speaks"),
    STUDYAT("studyAt"),
    WORKAT("workAt");

    private final String type;

    private Relationship(String type) {
      this.type = type;
    }
  }

  private static void printUsage() {
    System.out.println("Usage: DataFormatConverter inputDir outputDir");
    System.out.println("  inputDir  Directory containing SNB dataset files.");
    System.out.println("  outputDir Destination directory for output files.");
  }

  public static void main(String[] args) {
    if (args.length != 2) {
      printUsage();
      return;
    }

    String inputDir = args[0];
    String outputDir = args[1];
  }
}
